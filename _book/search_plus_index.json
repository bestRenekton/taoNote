{"./":{"url":"./","title":"概述","keywords":"","body":" taoNote taoNote 预览地址 这是什么? 一些笔记，方便自己查阅,会持续更新... 动机 看了 Winter 老师的《重学前端》，深有感触，自己平时虽然有记笔记的习惯，但是所记载的大多是分散的知识点，而这正好又是前端的特点，知识点多而杂。如果没有自己的知识体系，很难深入下去，所以用此项目来重构自己的知识体系，用科学的方法来学习前端。 明确你的前端学习路线与方法 建立知识架构 如果我们要给 JavaScript 知识做一个顶层目录，该怎么做呢？ 如果我们把一些特别流行的术语和问题，拼凑起来，可能会变成这样： 类型转换；this 指针；闭包；作用域链；原型链。。。 这其实不是我们想要的结果，因为这些知识点之间，没有任何逻辑关系。 对于任何计算机语言来说，必定是“用规定的文法，去表达特定语义，最终操作运行时的”一个过程。所以大致应该这样来划分 - 文法 - 词法 - 直接量、关键字、运算符。。。 - 语法 - 表达式、语句、函数、对象、模块。。。 - 语义 - 运行时 - 数据结构 - 执行过程（算法） 追本溯源 前端技术背后的核心思想 "},"doc/":{"url":"doc/","title":"目录","keywords":"","body":" 理论知识 硬知识 HTTP 标准 网络与安全 加密 OAuth 认证 JWT W3C 标准 HTML HTML5 CSS CSS3 JavaScript 文法 词法 直接量、关键字、运算符。。。 语法 表达式、语句、函数、对象、模块。。。 语义 运行时 数据结构 执行过程（算法） XML ECMAScript 标准 ES6 2015 ES7 2016 ES8 2017 ES9 2018 ES10 2019 ES11 2020 软知识 算法 基础算法 复杂度 排序 冒泡 快排 搜索 二分查找 数据结构 链表 树 图 设计模式 设计模式基础 设计模式实践 面向对象 单例 发布订阅模式 事件管理器 Vue 更新机制 react-redux 更新机制 代理模式 Vue3 组合模式 高阶组件 AOP 命令模式 富文本编辑 策略模式 js 的天然多态 组合模式 文件数结构 观察者模式 装饰器模式 面试 面试准备 JD 分析 一面 二面 三面 面试心态 职业规划 设计/UI/摄影 编码开发 开发工具 编辑器 VSCode WebStorm 效率工具 版本控制 Git SVN 调试/测试 调试 测试 测试分类 单元测试 E2E 测试 React 测试 打包/部署 打包 webpack Tree Shaking 代码压缩 按需引入 部署 Linux 容器 持续集成 运行环境 浏览器 实现原理 API DOM BOM 事件 跨域 性能优化 性能指标 性能优化军规 代码执行更快 防抖 节流 React 性能优化 Vue 性能优化 文件加载更快 打包压缩 缓存 SSR web 安全 持久化攻击 爬虫对抗 安全攻防 安全漏洞 同源策略 SQL 注入 XSS CSRF 兼容 端 PC 桌面应用 Electron NW.js 移动 原生开发 iOS Android 跨平台 H5+原生 公众号 小程序 Cordova、Ionic JavaScript 开发+原生渲染 React Native Weex 快应用 自绘 UI+原生 Flutter QT for mobile Node.js 类库框架 用于浏览器 jQuery Bootstrap React Vue Angular 用于 Node.js Express Koa 语言 Typescript AssemblyScript Dart PHP Python 技术趋势 serverless Faas + BaaS 云原生 微前端 PWA WebAssembly 函数式编程 书籍 JS 《JavaScript 高级程序设计》 《JavaScript 语言精粹》 《JavaScript 设计模式与开发实践》 CSS 《css 权威指南》 《CSS 世界》 框架 官网和源码， 《React 前端技术与工程实践》 《深入浅出 Vue.js》 网络： 《图解 http》 编程思想： 《Unix 编程艺术》 《代码大全》 工程思想： 《软件工程与计算》三卷 《人月神话》 可视化： 《数据之美》 "},"doc/development/version-control/git.html":{"url":"doc/development/version-control/git.html","title":"Git","keywords":"","body":" 图解 常用命令 新建 在当前目录新建一个 Git 代码库 git init 新建一个目录，将其初始化为 Git 代码库 git init [project-name] 下载一个项目和它的整个代码历史 git clone [url] 以当前分支的当前状态创建新分支并切换到新分支 git checkout -b [xxx] 新建一个分支，指向某个 tag git checkout -b [xxx] [tag] 配置 显示当前的 Git 配置 git config --list 编辑 Git 配置文件 git config -e [--global] 设置提交代码时的用户信息 git config [--global] user.name \"[name]\" git config [--global] user.email \"[email address]\" 设置别名 git config --global alias.co checkout git config --global alias.br branch 增加/删除文件 添加 git add . 添加当前目录的所有文件到暂存区 git add -p 添加每个变化前，都会要求确认.对于同一个文件的多处变化，可以实现分次提交 y add 此块 n 放弃此块 q 退出 add a add 整个文件 d 放弃整个文件 e 编辑 git add [file1] [file2] 指定文件 git add [dir] 添加指定目录,包括子目录 删除 git rm [file1][file2] 删除工作区文件，并且将这次删除放入暂存区 git rm --cached [file] 停止追踪指定文件，但该文件会保留在工作区 git mv [file-original][file-renamed] 改名文件，并且将这个改名放入暂存区(需要路径) 提交 提交暂存区的指定文件到仓库区 git commit [file1][file2] ... -m [message] 提交暂存区到仓库区 git commit -m [message] 使用一次新的 commit，替代上一次提交 git commit --amend -m [message] 变基 合并多次 commit git rebase -i [commitId] 比如提交了 1，2，3，想合并 3 者，只需要找到 1 之前的 commitId pick1 squash2 squash3 则提交就合并了，并且只有第一次的 msg 远程同步 下载远程仓库的所有变动 git fetch -a 显示所有远程仓库 git remote -v 显示某个远程仓库的信息 git remote show [remote] 取回远程仓库的变化，并与本地分支合并 git pull [branch] 上传本地指定分支到远程仓库 git push [branch] 强行推送当前分支到远程仓库，即使有冲突 git push -f 回滚撤销 重置暂存区与工作区，与上一次 commit 保持一致 git reset --hard 重置当前分支的指针为指定 commit git reset --mixed [commit] 同时重置暂存区，但工作区不变 git reset [commit] 默认--mixed git reset --hard [commit] 同时重置暂存区和工作区 git reset --soft [commit] 完全保留工作区和暂存区，仅改变 HEAD 的指向的位置 强制拉取 git fetch --all git reset --hard origin/master 恢复 commit，但是不会影响后续的提交 git revert [commit] 回滚单个文件 git checkout -- xx/xx 时光机，记录所有操作 git reflog 分支 列出所有本地分支 git branch 列出所有远程分支 git branch -r 列出所有本地分支和远程分支 git branch -a 新建一个分支，但依然停留在当前分支 git branch [branch-name] 新建一个分支，并切换到该分支 git checkout -b [branch] 切换到指定分支，并更新工作区 git checkout [branch-name] 切换到上一个分支 git checkout - 合并指定分支到当前分支 git merge [branch] 删除分支 git branch -d [branch-name] 删除远程分支 git push origin -d [branch-name] 查看信息 显示有变更的文件 git status 显示当前分支的版本历史 git log 优化 git lg 显示 commit 历史，以及每次 commit 发生变更的文件 git log --stat 优化 git ll 搜索提交历史，根据关键词 git log -S [keyword] git log -S [keyword] --stat 显示指定文件相关的每一次 diff git log -p [file] 显示指定文件每一行是什么人在什么时间修改过 git blame [file] 显示暂存区和工作区的差异 git diff 显示两次提交之间的差异 git diff [first-branch]...[second-branch] 显示某次提交的元数据和内容变化 git show [commit] 显示某次提交时，某个文件的内容 git show [commit] [filename] 显示所有提交过的用户，按提交次数排序 git shortlog -sn 显示今天你写了多少行代码 git diff --shortstat \"@{0 day ago}\" 标签 列出所有 tag git tag 查看 tag 信息 git show [tag] 新建 tag git tag [tag] 在当前 commit git tag [tag][commit] 在指定 commit 删除 tag git tag -d [tag] 本地 git push origin :refs/tags/[tagName] 远程 提交所有 tag git push [remote] --tags 新建一个分支，指向某个 tag git checkout -b [branch] [tag] 贮藏 git stash save \"xxx\" 贮藏 git stash list所有贮藏 git stash show ：显示做了哪些改动，默认 show 第一个存储 git stash show stash@{1}如果要显示其他存贮 git stash apply 应用某个存储,但不会把存储从存储列表中删除 git stash pop 应用某个存储,会把存储从存储列表中删除 git stash drop 丢弃 git stash clear 清空所有 一些 alias checkout => co branch => br log => lg简略,ll具体变动 diff => d add + commit -m => acm [msg] status => s 常用配置 alias.s=status alias.a=!git add . && git status alias.au=!git add -u . && git status alias.aa=!git add . && git add -u . && git status alias.c=commit alias.cm=commit -m alias.ca=commit --amend alias.ac=!git add . && git commit alias.acm=!git add . && git commit -m alias.l=log --graph --all --pretty=format:'%C(yellow)%h%C(cyan)%d%Creset %s %C(white)- %an, %ar%Creset' alias.ll=log --stat --abbrev-commit alias.lg=log --color --graph --pretty=format:'%C(bold white)%h%Creset -%C(bold green)%d%Creset %s %C(bold green)(%cr)%Creset %C(bold blue)%Creset' --abbrev-commit --date=relative alias.llg=log --color --graph --pretty=format:'%C(bold white)%H %d%Creset%n%s%n%+b%C(bold blue)%an %Creset %C(bold green)%cr (%ci)' --abbrev-commit alias.d=diff alias.master=checkout master alias.spull=svn rebase alias.spush=svn dcommit alias.alias=!git config --list | grep 'alias\\.' | sed 's/alias\\.\\([^=]*\\)=\\(.*\\)/\\1\\ => \\2/' | sort alias.co=checkout alias.br=branch 案例 克隆 带账号密码 git clone http://账号%40qq.com:密码@gitee.com/xxxxxx.git 注意：用户名密码中一定要转义 @符号转码后变成了%40 解决 git pull/push 每次都需要输入密码问题 进入你的项目目录 git config --global credential.helper store 下次 push 或者 pull 会输入一次密码，之后不需要了 --depth=1 只拉去最近一次的提交记录 git clone -b [branch] --depth=1 [url]可以拉对应分支的最近一次提交，无其他记录了 只 pull 某一个文件/夹 git config core.sparsecheckout true //此方法适用于 Git1.7.0 以后版本，之前的版本没有这个功能 在.git/info/sparse-checkout 文件中（如果没有则创建）添加指定的文件/夹 比如,则只会有 dist /dist 自动补全分支名 git-completion brew install bash-completion vim ~/.zshrc# auto-completion if [ -f /opt/local/etc/profile.d/bash_completion.sh ]; then . /opt/local/etc/profile.d/bash_completion.sh fi source ~/.zshrc "},"doc/run/browser/performance/fast-implement/throttle/throttle.html":{"url":"doc/run/browser/performance/fast-implement/throttle/throttle.html","title":"防抖/节流","keywords":"","body":"防抖 每次触发事件时都取消之前的延时调用方法 function debounce(fn) { let timeout = null; // 创建一个标记用来存放定时器的返回值 return function () { // 这里不能用箭头函数，用了this指向window,以前指向input // 每当用户输入的时候把前一个 setTimeout clear 掉 clearTimeout(timeout); // 然后又创建一个新的 setTimeout, 这样就能保证interval 间隔内如果时间持续触发，就不会执行 fn 函数 timeout = setTimeout(() => { fn.apply(this, arguments); }, 500); }; } function handle(e) { console.log(e.target.value); } document.getElementById('aa').addEventListener('input', debounce(handle)); 节流 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率 function throttle(fn) { let canRun = true; // 通过闭包保存一个标记 return function () {// 这里不能用箭头函数，用了this指向window,以前指向input // 在函数开头判断标记是否为true，不为true则return if (!canRun) return; // 立即设置为false canRun = false; // 将外部传入的函数的执行放在setTimeout中 setTimeout(() => { // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。 // 当定时器没有执行的时候标记永远是false，在开头被return掉 fn.apply(this, arguments); canRun = true; }, 500); }; } function handle(e) { console.log(e.target.value); } document.getElementById('aa').addEventListener('input', throttle(handle)); "},"doc/run/browser/performance/fast-load/cache/":{"url":"doc/run/browser/performance/fast-load/cache/","title":"缓存","keywords":"","body":"缓存的意义 缓解服务器压力，不用每次去请求资源； 提升性能，打开本地资源速度当然比请求回来再打开要快得多； 减少带宽消耗； 缓存类型 代理服务器缓存 代理服务器缓存原理和浏览器端类似，但规模要大得多，因为是为成千上万的用户提供缓存机制。 网关缓存 CDNS(网络内容分发商)分布网关缓存到整个（或部分）互联网上，并出售缓存服务给需要的网站，比如国内的七牛云、又拍云都有这种服务。 数据库缓存 频繁的进行数据库查询，这样可能导致数据库不堪重负，所以存起来，下次直接用。 客户端缓存 数据不被序列化 Cache 数据序列化Storage Cookie Session localStorage sessionStorage indexDB Web SQL 离线缓存 serviceWorker "},"doc/run/browser/performance/fast-load/cache/clientCache.html":{"url":"doc/run/browser/performance/fast-load/cache/clientCache.html","title":"clientCache","keywords":"","body":"Cache 我们知道HTTP的缓存属于客户端缓存，后面会提到为什么属于客户端缓存。所以我们认为浏览器存在一个缓存数据库，用于储存一些不经常变化的静态文件（图片、css、js等）。我们将缓存分为强制缓存和协商缓存。下面我将分别详细的介绍这两种缓存的缓存规则。 缓存策略 强制缓存 当缓存数据库中已有所请求的数据时。客户端直接从缓存数据库中获取数据。当缓存数据库中没有所请求的数据时，客户端的才会从服务端获取数据。触发强制缓存后，Firefox浏览器表现为一个灰色的200状态码。chrome为200 (from disk cache)或是200 OK (from memory cache)，这里chrome会根据你的内存情况来选择存在内存还是硬盘 Expires Cache-Control max-age=[秒] 缓存的时长，也是响应的最大的Age值 no-store 不缓存请求或是响应的任何内容 no-cache 强制源服务器再次验证缓存是否可用 max-age=0和no-cache应该是从语气上不同。max-age=0是告诉客户端资源的缓存到期应该向服务器验证缓存的有效性。而no-cache则告诉客户端使用缓存前必须向服务器验证缓存的有效性。 private 客户端可以缓存 public 客户端和代理服务器都可以缓存 Cache-Control优先级大于Expires 协商缓存 又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回304，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据。 两类缓存机制可以同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商。 Last-Modified If-Moified-Since 在浏览器第一次请求某一个URL时，服务器端的返回状态码会是200，响应的实体内容是客户端请求的资源，同时有一个Last-Modified的属性标记此文件在服务器端最后被修改的时间。Last-Modified : Fri , 12 May 2006 18:53:33 GMT 当浏览器第二次请求这个URL的时候，根据HTTP协议规定，浏览器会把第一次Last-Modified的值存储在If-Modified-Since里面发送给服务端来验证资源有没有修改。If-Modified-Since : Fri , 12 May 2006 18:53:33 GMT 服务端通过If-Modified-Since字段来判断在这两次访问期间资源有没有被修改过，从而决定是否返回完整的资源。如果有修改正常返回资源，状态码200，如果没有修改只返回响应头，状态码304，告知浏览器资源的本地缓存还可用。 Last-Modified有几个缺点：没法准确的判断资源是否真的修改了，比如某个文件在1秒内频繁更改了多次，根据Last-Modified的时间(单位是秒)是判断不出来的，再比如，某个资源只是修改了，但实际内容并没有发生变化，Last-Modified也无法判断出来，因此在HTTP/1.1中还推出了ETag这个字段👇 Etag If-None-Match 在浏览器第一次请求某一个URL时，服务器可以通过某种自定的算法对资源生成一个唯一的标识(比如md5标识)， 并返给浏览器ETag: abc-123456 当浏览器第二次请求这个URL的时候，根据HTTP协议规定，浏览器回把第一次ETag的值存储在If-None-Match里面发送给服务端来验证资源有没有修改。If-None-Match: abc-123456 Get请求中，当且仅当服务器上没有任何资源的ETag属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为200。如果没有资源的ETag值相匹配，那么返回304状态码。 POST、PUT等请求改变文件的请求，如果没有资源的ETag值相匹配，那么返回412状态码。 当然和Last-Modified相比，ETag也有自己的缺点，比如由于需要对资源进行生成标识，性能方面就势必有所牺牲。 If-None-Match优先级大于Last-Modified启发式缓存 Age:23146 Cache-Control: public Date:Tue, 28 Nov 2017 12:26:41 GMT Last-Modified:Tue, 28 Nov 2017 05:14:02 GMT Vary:Accept-Encoding 如果浏览器用来确定缓存过期时间的字段一个都没有！那该怎么办？启发式缓存！ 根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。 用户行为 打开新窗口 如果指定cache-control的值为private、no-cache、must-revalidate,那么打开新窗口访问时都会重新访问服务器。而如果指定了max-age值,那么在此值内的时间里就不会重新访问服务器 在地址栏回车 如果值为private或must-revalidate,则只有第一次访问时会访问服务器,以后就不再访问。如果值为no-cache,那么每次都会访问。如果值为max-age,则在过期之前不会重复访问。 按后退按扭 如果值为private、must-revalidate、max-age,则不会重访问,而如果为no-cache,则每次都重复访问. 按刷新按扭 F5 无论为何值,都会重复访问.请求带上If-Modify-since，去服务器看看这个文件是否有过期了 按强制刷新按钮 CTRL/F5 浏览器删除缓存，当做首次进入重新请求(返回状态码200) 实践 最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效。 前端打包加hash webpack给我们提供了三种哈希值计算方式，分别是hash、chunkhash和contenthash hash 只要有一个文件变化，整个项目都hash都会变，显然不行 const path = require('path'); module.exports = { entry: { index: './src/index.js', main: './src/main.js' }, output: { path: path.resolve(__dirname, 'dist'), filename: '[name].[hash].js', } } chunkhash 同一模块中一个文件变化，整个模块hash变化。看起来还行，不过如果js和css是分开了的，只要其中一个变化，整个模块的js和css都会变 module.exports = { output: { path: path.resolve(__dirname, 'dist'), filename: '[name].[chunkhash].js', } } contenthash 只要文件内容不一样，文件产生的哈希值就不一样，显然这就是我们想要的 module.exports = { output: { path: path.resolve(__dirname, 'dist') filename: '[name].[contenthash].js', } }; Nginx 官方默认开启ETag，所以这里就不用做特别设置了 后端 强制缓存res.setHeader('Cache-Control', 'public, max-age=xxx'); 协商缓存res.setHeader('Cache-Control', 'public, max-age=0'); res.setHeader('Last-Modified', xxx); res.setHeader('ETag', xxx); 当然也有很多库,比如koa的koa-staticconst KoaStatic = require('koa-static'); app.use(KoaStatic('./',{ maxAge: 365 * 24 * 60 * 60 })); "},"doc/run/browser/performance/fast-load/cache/storage.html":{"url":"doc/run/browser/performance/fast-load/cache/storage.html","title":"storage","keywords":"","body":"storage "},"doc/run/browser/performance/fast-load/cache/offlineCache.html":{"url":"doc/run/browser/performance/fast-load/cache/offlineCache.html","title":"离线缓存","keywords":"","body":"离线缓存 "}}