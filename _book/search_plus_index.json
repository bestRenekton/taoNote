{"./":{"url":"./","title":"概述","keywords":"","body":"taoNote 这是什么? 一些笔记，方便自己查阅,会持续更新... "},"doc/":{"url":"doc/","title":"目录","keywords":"","body":" 理论知识 硬知识 HTTP标准 W3C标准 HTML HTML5 CSS CSS3 JavaScript ECMAScript标准 DOM BOM XML ECMAScript标准 ES6 2015 ES7 2016 ES8 2017 ES9 2018 ES10 2019 ES11 2020 软知识 算法 基础算法 复杂度 排序 冒泡 快排 搜索 二分查找 数据结构 链表 树 图 设计模式 设计模式基础 设计模式实践 面向对象 单例 观察者模式 代理模式 装饰器模式 面试 面试准备 JD分析 一面 二面 三面 面试心态 职业规划 设计/UI/摄影 编码开发 开发工具 编辑器 VSCode WebStorm 效率工具 版本控制 Git SVN 调试 测试 测试分类 单元测试 E2E测试 React测试 打包 部署 Linux 容器 持续集成 运行环境 浏览器 性能优化 性能指标 性能优化军规 代码执行更快 防抖 节流 React性能优化 Vue性能优化 文件加载更快 打包压缩 缓存 web安全 持久化攻击 爬虫对抗 安全攻防 安全漏洞 同源策略 SQL注入 XSS CSRF 兼容 端 PC 桌面应用 Electron NW.js 移动 原生开发 iOS Android 跨平台 H5+原生 公众号 小程序 Cordova、Ionic JavaScript开发+原生渲染 React Native Weex 快应用 自绘UI+原生 Flutter QT for mobile Node.js 类库框架 用于浏览器 jQuery Bootstrap React Vue Angular 用于Node.js Express Koa 语言 Typescript AssemblyScript Dart PHP Python "},"doc/run/browser/performance/fast-implement/throttle/throttle.html":{"url":"doc/run/browser/performance/fast-implement/throttle/throttle.html","title":"防抖/节流","keywords":"","body":"防抖 每次触发事件时都取消之前的延时调用方法 function debounce(fn) { let timeout = null; // 创建一个标记用来存放定时器的返回值 return function () { // 这里不能用箭头函数，用了this指向window,以前指向input // 每当用户输入的时候把前一个 setTimeout clear 掉 clearTimeout(timeout); // 然后又创建一个新的 setTimeout, 这样就能保证interval 间隔内如果时间持续触发，就不会执行 fn 函数 timeout = setTimeout(() => { fn.apply(this, arguments); }, 500); }; } function handle(e) { console.log(e.target.value); } document.getElementById('aa').addEventListener('input', debounce(handle)); 节流 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率 function throttle(fn) { let canRun = true; // 通过闭包保存一个标记 return function () {// 这里不能用箭头函数，用了this指向window,以前指向input // 在函数开头判断标记是否为true，不为true则return if (!canRun) return; // 立即设置为false canRun = false; // 将外部传入的函数的执行放在setTimeout中 setTimeout(() => { // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。 // 当定时器没有执行的时候标记永远是false，在开头被return掉 fn.apply(this, arguments); canRun = true; }, 500); }; } function handle(e) { console.log(e.target.value); } document.getElementById('aa').addEventListener('input', throttle(handle)); "},"doc/run/browser/performance/fast-load/cache/":{"url":"doc/run/browser/performance/fast-load/cache/","title":"缓存","keywords":"","body":"缓存的意义 缓解服务器压力，不用每次去请求资源； 提升性能，打开本地资源速度当然比请求回来再打开要快得多； 减少带宽消耗； 缓存类型 代理服务器缓存 代理服务器缓存原理和浏览器端类似，但规模要大得多，因为是为成千上万的用户提供缓存机制。 网关缓存 CDNS(网络内容分发商)分布网关缓存到整个（或部分）互联网上，并出售缓存服务给需要的网站，比如国内的七牛云、又拍云都有这种服务。 数据库缓存 频繁的进行数据库查询，这样可能导致数据库不堪重负，所以存起来，下次直接用。 客户端缓存 数据不被序列化 Cache 数据序列化Storage Cookie Session localStorage sessionStorage indexDB Web SQL 离线缓存 serviceWorker "},"doc/run/browser/performance/fast-load/cache/clientCache.html":{"url":"doc/run/browser/performance/fast-load/cache/clientCache.html","title":"clientCache","keywords":"","body":"Cache 我们知道HTTP的缓存属于客户端缓存，后面会提到为什么属于客户端缓存。所以我们认为浏览器存在一个缓存数据库，用于储存一些不经常变化的静态文件（图片、css、js等）。我们将缓存分为强制缓存和协商缓存。下面我将分别详细的介绍这两种缓存的缓存规则。 缓存策略 强制缓存 当缓存数据库中已有所请求的数据时。客户端直接从缓存数据库中获取数据。当缓存数据库中没有所请求的数据时，客户端的才会从服务端获取数据。触发强制缓存后，Firefox浏览器表现为一个灰色的200状态码。chrome为200 (from disk cache)或是200 OK (from memory cache)，这里chrome会根据你的内存情况来选择存在内存还是硬盘 Expires Cache-Control max-age=[秒] 缓存的时长，也是响应的最大的Age值 no-store 不缓存请求或是响应的任何内容 no-cache 强制源服务器再次验证缓存是否可用 max-age=0和no-cache应该是从语气上不同。max-age=0是告诉客户端资源的缓存到期应该向服务器验证缓存的有效性。而no-cache则告诉客户端使用缓存前必须向服务器验证缓存的有效性。 private 客户端可以缓存 public 客户端和代理服务器都可以缓存 Cache-Control优先级大于Expires 协商缓存 又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回304，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据。 两类缓存机制可以同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商。 Last-Modified If-Moified-Since 在浏览器第一次请求某一个URL时，服务器端的返回状态码会是200，响应的实体内容是客户端请求的资源，同时有一个Last-Modified的属性标记此文件在服务器端最后被修改的时间。Last-Modified : Fri , 12 May 2006 18:53:33 GMT 当浏览器第二次请求这个URL的时候，根据HTTP协议规定，浏览器会把第一次Last-Modified的值存储在If-Modified-Since里面发送给服务端来验证资源有没有修改。If-Modified-Since : Fri , 12 May 2006 18:53:33 GMT 服务端通过If-Modified-Since字段来判断在这两次访问期间资源有没有被修改过，从而决定是否返回完整的资源。如果有修改正常返回资源，状态码200，如果没有修改只返回响应头，状态码304，告知浏览器资源的本地缓存还可用。 Last-Modified有几个缺点：没法准确的判断资源是否真的修改了，比如某个文件在1秒内频繁更改了多次，根据Last-Modified的时间(单位是秒)是判断不出来的，再比如，某个资源只是修改了，但实际内容并没有发生变化，Last-Modified也无法判断出来，因此在HTTP/1.1中还推出了ETag这个字段👇 Etag If-None-Match 在浏览器第一次请求某一个URL时，服务器可以通过某种自定的算法对资源生成一个唯一的标识(比如md5标识)， 并返给浏览器ETag: abc-123456 当浏览器第二次请求这个URL的时候，根据HTTP协议规定，浏览器回把第一次ETag的值存储在If-None-Match里面发送给服务端来验证资源有没有修改。If-None-Match: abc-123456 Get请求中，当且仅当服务器上没有任何资源的ETag属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为200。如果没有资源的ETag值相匹配，那么返回304状态码。 POST、PUT等请求改变文件的请求，如果没有资源的ETag值相匹配，那么返回412状态码。 当然和Last-Modified相比，ETag也有自己的缺点，比如由于需要对资源进行生成标识，性能方面就势必有所牺牲。 If-None-Match优先级大于Last-Modified启发式缓存 Age:23146 Cache-Control: public Date:Tue, 28 Nov 2017 12:26:41 GMT Last-Modified:Tue, 28 Nov 2017 05:14:02 GMT Vary:Accept-Encoding 如果浏览器用来确定缓存过期时间的字段一个都没有！那该怎么办？启发式缓存！ 根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。 用户行为 打开新窗口 如果指定cache-control的值为private、no-cache、must-revalidate,那么打开新窗口访问时都会重新访问服务器。而如果指定了max-age值,那么在此值内的时间里就不会重新访问服务器 在地址栏回车 如果值为private或must-revalidate,则只有第一次访问时会访问服务器,以后就不再访问。如果值为no-cache,那么每次都会访问。如果值为max-age,则在过期之前不会重复访问。 按后退按扭 如果值为private、must-revalidate、max-age,则不会重访问,而如果为no-cache,则每次都重复访问. 按刷新按扭 F5 无论为何值,都会重复访问.请求带上If-Modify-since，去服务器看看这个文件是否有过期了 按强制刷新按钮 CTRL/F5 浏览器删除缓存，当做首次进入重新请求(返回状态码200) 实践 最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效。 前端打包加hash webpack给我们提供了三种哈希值计算方式，分别是hash、chunkhash和contenthash hash 只要有一个文件变化，整个项目都hash都会变，显然不行 const path = require('path'); module.exports = { entry: { index: './src/index.js', main: './src/main.js' }, output: { path: path.resolve(__dirname, 'dist'), filename: '[name].[hash].js', } } chunkhash 同一模块中一个文件变化，整个模块hash变化。看起来还行，不过如果js和css是分开了的，只要其中一个变化，整个模块的js和css都会变 module.exports = { output: { path: path.resolve(__dirname, 'dist'), filename: '[name].[chunkhash].js', } } contenthash 只要文件内容不一样，文件产生的哈希值就不一样，显然这就是我们想要的 module.exports = { output: { path: path.resolve(__dirname, 'dist') filename: '[name].[contenthash].js', } }; Nginx 官方默认开启ETag，所以这里就不用做特别设置了 后端 强制缓存res.setHeader('Cache-Control', 'public, max-age=xxx'); 协商缓存res.setHeader('Cache-Control', 'public, max-age=0'); res.setHeader('Last-Modified', xxx); res.setHeader('ETag', xxx); 当然也有很多库,比如koa的koa-staticconst KoaStatic = require('koa-static'); app.use(KoaStatic('./',{ maxAge: 365 * 24 * 60 * 60 })); "},"doc/run/browser/performance/fast-load/cache/storage.html":{"url":"doc/run/browser/performance/fast-load/cache/storage.html","title":"storage","keywords":"","body":"storage "},"doc/run/browser/performance/fast-load/cache/offlineCache.html":{"url":"doc/run/browser/performance/fast-load/cache/offlineCache.html","title":"离线缓存","keywords":"","body":"离线缓存 "}}