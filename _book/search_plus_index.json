{"./":{"url":"./","title":"概述","keywords":"","body":" taoNote taoNote 预览地址 这是什么? 一些笔记，方便自己查阅,会持续更新... 动机 看了 Winter 老师的《重学前端》，深有感触，自己平时虽然有记笔记的习惯，但是所记载的大多是分散的知识点，而这正好又是前端的特点，知识点多而杂。如果没有自己的知识体系，很难深入下去，所以用此项目来重构自己的知识体系，用科学的方法来学习前端。 明确你的前端学习路线与方法 建立知识架构 如果我们要给 JavaScript 知识做一个顶层目录，该怎么做呢？ 如果我们把一些特别流行的术语和问题，拼凑起来，可能会变成这样： 类型转换；this 指针；闭包；作用域链；原型链。。。 这其实不是我们想要的结果，因为这些知识点之间，没有任何逻辑关系。 对于任何计算机语言来说，必定是“用规定的文法，去表达特定语义，最终操作运行时的”一个过程。所以大致应该这样来划分 - 文法 - 词法 - 直接量、关键字、运算符。。。 - 语法 - 表达式、语句、函数、对象、模块。。。 - 语义 - 运行时 - 数据结构 - 执行过程（算法） 追本溯源 前端技术背后的核心思想 技能树 "},"doc/":{"url":"doc/","title":"目录","keywords":"","body":" 理论知识 硬知识 HTTP 标准 网络与安全 加密 OAuth 认证 JWT W3C 标准 HTML HTML5 CSS CSS3 JavaScript 文法 词法 直接量、关键字、运算符。。。 语法 表达式、语句、函数、对象、模块。。。 语义 运行时 数据结构 执行过程（算法） XML ECMAScript 标准 ES6 2015 ES7 2016 ES8 2017 ES9 2018 ES10 2019 ES11 2020 软知识 算法 基础算法 复杂度 排序 冒泡 快排 搜索 二分查找 数据结构 链表 树 图 设计模式 设计模式基础 设计模式实践 面向对象 单例 发布订阅模式 事件管理器 Vue 更新机制 react-redux 更新机制 代理模式 Vue3 组合模式 高阶组件 AOP 命令模式 富文本编辑 策略模式 js 的天然多态 组合模式 文件数结构 观察者模式 装饰器模式 面试 面试准备 JD 分析 一面 二面 三面 面试心态 职业规划 设计/UI/摄影 编码开发 开发工具 编辑器 VSCode WebStorm 效率工具 版本控制 Git SVN 调试/测试 调试 测试 测试分类 单元测试 E2E 测试 React 测试 打包/部署 打包 webpack Tree Shaking 代码压缩 按需引入 部署 Linux 容器 持续集成 运行环境 浏览器 实现原理 API DOM BOM 事件 跨域 性能优化 性能指标 性能优化军规 代码执行更快 防抖 节流 React 性能优化 Vue 性能优化 文件加载更快 打包压缩 缓存 SSR 异常监控 捕获异常 Sentry web 安全 持久化攻击 爬虫对抗 安全攻防 安全漏洞 同源策略 SQL 注入 XSS CSRF 兼容 端 PC 桌面应用 Electron NW.js 移动 原生开发 iOS Android 跨平台 H5+原生 公众号 小程序 Cordova、Ionic JavaScript 开发+原生渲染 React Native Weex 快应用 自绘 UI+原生 Flutter QT for mobile Node.js 类库框架 用于浏览器 jQuery Bootstrap React Vue Angular 用于 Node.js Express Koa 语言 Typescript AssemblyScript Dart PHP Python 技术趋势 serverless Faas + BaaS 云原生 微前端 PWA WebAssembly 函数式编程 书籍 JS 《JavaScript 高级程序设计》 《JavaScript 语言精粹》 《JavaScript 设计模式与开发实践》 CSS 《css 权威指南》 《CSS 世界》 框架 官网和源码， 《React 前端技术与工程实践》 《深入浅出 Vue.js》 网络： 《图解 http》 编程思想： 《Unix 编程艺术》 《代码大全》 工程思想： 《软件工程与计算》三卷 《人月神话》 可视化： 《数据之美》 "},"doc/knowledge/hard/NetWork/OAuth.html":{"url":"doc/knowledge/hard/NetWork/OAuth.html","title":"OAuth 认证","keywords":"","body":" OAuth 原理 OAuth 就是一种授权机制。数据的所有者告诉系统，同意授权第三方应用进入系统，获取这些数据。系统从而产生一个短期的进入令牌（token），用来代替密码，供第三方应用使用。 令牌与密码差异 令牌是短期的，到期会自动失效，用户自己无法修改。密码一般长期有效，用户不修改，就不会发生变化。 令牌可以被数据所有者撤销，会立即失效。密码一般不允许被他人撤销。 令牌有权限范围（scope），比如只能进小区的二号门。对于网络服务来说，只读令牌就比读写令牌更安全。密码一般是完整权限。 四种方式 授权码式 这种方式是最常用的流程，安全性也最高，它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。 A 前端跳转 B，同时携带clientId,A后端的callBack B 要求用户登录，之后询问是否同意授权,如果同意，则会打到 A 后端的 callBack 请求，并携带授权码code A 后端拿到授权码code，并使用client_secret去请求 B 的令牌token，因为是后端请求，所以很安全 A 后端拿到令牌token，去请求 B 的 API 隐藏式 有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端,是很不安全的。 A 前端跳转 B，同时携带clientId,A前端地址的callBack B 直接将令牌token返回到 A 前端地址的锚点上，比如https://a.com/callback#token=ACCESS_TOKEN 密码式 直接使用密码去请求凭证，需要用户给出自己的用户名/密码，显然风险很大，因此只适用于其他授权方式都无法采用的情况，而且必须是用户高度信任的应用。 A 前端请求 B 接口，同时携带clientId,username,password B 直接在返回里给出令牌token 凭证式 适用于没有前端的命令行应用，即在命令行下请求令牌。 A 在命令行向 B 发出请求,携带clientId,client_secret B 验证后，直接返回令牌token 令牌使用,更新 网站拿到令牌以后，就可以向 B 网站的 API 请求数据了。每个发到 API 的请求，都必须带有令牌。可以统一携带在 header 中 const result = await axios({ method: \"get\", url: `https://api.github.com/user`, headers: { accept: \"application/json\", Authorization: `token ${accessToken}`, }, }); 令牌的有效期到了，如果让用户重新走一遍上面的流程，再申请一个新的令牌，很可能体验不好，而且也没有必要。OAuth 2.0 允许用户自动更新令牌。 例子 Github A 网站让用户跳转到 GitHub。 GitHub 要求用户登录，然后询问\"A 网站要求获得 xx 权限，你是否同意？\" 用户同意，GitHub 就会重定向回 A 网站，同时发回一个授权码。 A 网站使用授权码，向 GitHub 请求令牌。 GitHub 返回令牌. A 网站使用令牌，向 GitHub 请求用户数据。 "},"doc/development/version-control/git.html":{"url":"doc/development/version-control/git.html","title":"Git","keywords":"","body":" 图解 常用命令 新建 在当前目录新建一个 Git 代码库 git init 新建一个目录，将其初始化为 Git 代码库 git init [project-name] 下载一个项目和它的整个代码历史 git clone [url] 以当前分支的当前状态创建新分支并切换到新分支 git checkout -b [xxx] 新建一个分支，指向某个 tag git checkout -b [xxx] [tag] 配置 显示当前的 Git 配置 git config --list 编辑 Git 配置文件 git config -e [--global] 设置提交代码时的用户信息 git config [--global] user.name \"[name]\" git config [--global] user.email \"[email address]\" 设置别名 git config --global alias.co checkout git config --global alias.br branch git config --global alias.rank \"shortlog -sn --no-merges\" 增加/删除文件 添加 git add . 添加当前目录的所有文件到暂存区 git add -p 添加每个变化前，都会要求确认.对于同一个文件的多处变化，可以实现分次提交 y add 此块 n 放弃此块 q 退出 add a add 整个文件 d 放弃整个文件 e 编辑 git add [file1] [file2] 指定文件 git add [dir] 添加指定目录,包括子目录 删除 git rm [file1][file2] 删除工作区文件，并且将这次删除放入暂存区 git rm --cached [file] 停止追踪指定文件，但该文件会保留在工作区 git mv [file-original][file-renamed] 改名文件，并且将这个改名放入暂存区(需要路径) 提交 提交暂存区的指定文件到仓库区 git commit [file1][file2] ... -m [message] 提交暂存区到仓库区 git commit -m [message] 使用一次新的 commit，替代上一次提交 git commit --amend -m [message] 变基 合并多次 commit git rebase -i [commitId] 比如提交了 1，2，3，想合并 3 者，只需要找到 1 之前的 commitId pick1 squash2 squash3 则提交就合并了，并且只有第一次的 msg 远程同步 下载远程仓库的所有变动 git fetch -a 显示所有远程仓库 git remote -v 显示某个远程仓库的信息 git remote show [remote] 取回远程仓库的变化，并与本地分支合并 git pull [branch] 上传本地指定分支到远程仓库 git push [branch] 强行推送当前分支到远程仓库，即使有冲突 git push -f 回滚撤销 重置暂存区与工作区，与上一次 commit 保持一致 git reset --hard 重置当前分支的指针为指定 commit git reset --mixed [commit] 同时重置暂存区，但工作区不变 git reset [commit] 默认--mixed git reset --hard [commit] 同时重置暂存区和工作区 git reset --soft [commit] 完全保留工作区和暂存区，仅改变 HEAD 的指向的位置 强制拉取 git fetch --all git reset --hard origin/master 恢复 commit，但是不会影响后续的提交 git revert [commit] 回滚单个文件 git checkout -- xx/xx 时光机，记录所有操作 git reflog 分支 列出所有本地分支 git branch 列出所有远程分支 git branch -r 列出所有本地分支和远程分支 git branch -a 新建一个分支，但依然停留在当前分支 git branch [branch-name] 新建一个分支，并切换到该分支 git checkout -b [branch] 切换到指定分支，并更新工作区 git checkout [branch-name] 切换到上一个分支 git checkout - 合并指定分支到当前分支 git merge [branch] 删除分支 git branch -d [branch-name] 删除远程分支 git push origin -d [branch-name] 查看信息 显示有变更的文件 git status 显示当前分支的版本历史 git log 优化 git lg 显示 commit 历史，以及每次 commit 发生变更的文件 git log --stat 优化 git ll 搜索提交历史，根据关键词 git log -S [keyword] git log -S [keyword] --stat 显示指定文件相关的每一次 diff git log -p [file] 显示指定文件每一行是什么人在什么时间修改过 git blame [file] 显示暂存区和工作区的差异 git diff 显示两次提交之间的差异 git diff [first-branch]...[second-branch] 显示某次提交的元数据和内容变化 git show [commit] 显示某次提交时，某个文件的内容 git show [commit] [filename] 显示所有提交过的用户，按提交次数排序 git shortlog -sn 显示今天你写了多少行代码 git diff --shortstat \"@{0 day ago}\" 标签 列出所有 tag git tag 查看 tag 信息 git show [tag] 新建 tag git tag [tag] 在当前 commit git tag [tag][commit] 在指定 commit 删除 tag git tag -d [tag] 本地 git push origin :refs/tags/[tagName] 远程 提交所有 tag git push [remote] --tags 新建一个分支，指向某个 tag git checkout -b [branch] [tag] 贮藏 git stash save \"xxx\" 贮藏 git stash list所有贮藏 git stash show ：显示做了哪些改动，默认 show 第一个存储 git stash show stash@{1}如果要显示其他存贮 git stash apply 应用某个存储,但不会把存储从存储列表中删除 git stash pop 应用某个存储,会把存储从存储列表中删除 git stash drop 丢弃 git stash clear 清空所有 一些 alias checkout => co branch => br log => lg简略,ll具体变动 diff => d add + commit -m => acm [msg] status => s 常用配置 alias.s=status alias.a=!git add . && git status alias.au=!git add -u . && git status alias.aa=!git add . && git add -u . && git status alias.c=commit alias.cm=commit -m alias.ca=commit --amend alias.ac=!git add . && git commit alias.acm=!git add . && git commit -m alias.l=log --graph --all --pretty=format:'%C(yellow)%h%C(cyan)%d%Creset %s %C(white)- %an, %ar%Creset' alias.ll=log --stat --abbrev-commit alias.lg=log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' --abbrev-commit alias.lga=log --color --graph --all --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)%Creset' --abbrev-commit alias.llg=log --color --graph --pretty=format:'%C(bold white)%H %d%Creset%n%s%n%+b%C(bold blue)%an %Creset %C(bold green)%cr (%ci)' --abbrev-commit alias.d=diff alias.master=checkout master alias.spull=svn rebase alias.spush=svn dcommit alias.alias=!git config --list | grep 'alias\\.' | sed 's/alias\\.\\([^=]*\\)=\\(.*\\)/\\1\\ => \\2/' | sort alias.co=checkout alias.br=branch alias.rank=shortlog -sn --no-merges 案例 克隆 带账号密码 git clone http://账号%40qq.com:密码@gitee.com/xxxxxx.git 注意：用户名密码中一定要转义 @符号转码后变成了%40 解决 git pull/push 每次都需要输入密码问题 进入你的项目目录 git config --global credential.helper store 下次 push 或者 pull 会输入一次密码，之后不需要了 --depth=1 只拉去最近一次的提交记录 git clone -b [branch] --depth=1 [url]可以拉对应分支的最近一次提交，无其他记录了 只 pull 某一个文件/夹 git config core.sparsecheckout true //此方法适用于 Git1.7.0 以后版本，之前的版本没有这个功能 在.git/info/sparse-checkout 文件中（如果没有则创建）添加指定的文件/夹 比如,则只会有 dist /dist 自动补全分支名 git-completion brew install bash-completion vim ~/.zshrc# auto-completion if [ -f /opt/local/etc/profile.d/bash_completion.sh ]; then . /opt/local/etc/profile.d/bash_completion.sh fi source ~/.zshrc "},"doc/run/browser/performance/fast-implement/throttle/throttle.html":{"url":"doc/run/browser/performance/fast-implement/throttle/throttle.html","title":"防抖/节流","keywords":"","body":"防抖 每次触发事件时都取消之前的延时调用方法 function debounce(fn) { let timeout = null; // 创建一个标记用来存放定时器的返回值 return function () { // 这里不能用箭头函数，用了this指向window,以前指向input // 每当用户输入的时候把前一个 setTimeout clear 掉 clearTimeout(timeout); // 然后又创建一个新的 setTimeout, 这样就能保证interval 间隔内如果时间持续触发，就不会执行 fn 函数 timeout = setTimeout(() => { fn.apply(this, arguments); }, 500); }; } function handle(e) { console.log(e.target.value); } document.getElementById('aa').addEventListener('input', debounce(handle)); 节流 高频事件触发，但在n秒内只会执行一次，所以节流会稀释函数的执行频率 function throttle(fn) { let canRun = true; // 通过闭包保存一个标记 return function () {// 这里不能用箭头函数，用了this指向window,以前指向input // 在函数开头判断标记是否为true，不为true则return if (!canRun) return; // 立即设置为false canRun = false; // 将外部传入的函数的执行放在setTimeout中 setTimeout(() => { // 最后在setTimeout执行完毕后再把标记设置为true(关键)表示可以执行下一次循环了。 // 当定时器没有执行的时候标记永远是false，在开头被return掉 fn.apply(this, arguments); canRun = true; }, 500); }; } function handle(e) { console.log(e.target.value); } document.getElementById('aa').addEventListener('input', throttle(handle)); "},"doc/run/browser/performance/fast-load/cache/":{"url":"doc/run/browser/performance/fast-load/cache/","title":"缓存","keywords":"","body":"缓存的意义 缓解服务器压力，不用每次去请求资源； 提升性能，打开本地资源速度当然比请求回来再打开要快得多； 减少带宽消耗； 缓存类型 代理服务器缓存 代理服务器缓存原理和浏览器端类似，但规模要大得多，因为是为成千上万的用户提供缓存机制。 网关缓存 CDNS(网络内容分发商)分布网关缓存到整个（或部分）互联网上，并出售缓存服务给需要的网站，比如国内的七牛云、又拍云都有这种服务。 数据库缓存 频繁的进行数据库查询，这样可能导致数据库不堪重负，所以存起来，下次直接用。 客户端缓存 数据不被序列化 Cache 数据序列化Storage Cookie Session localStorage sessionStorage indexDB Web SQL 离线缓存 serviceWorker "},"doc/run/browser/performance/fast-load/cache/clientCache.html":{"url":"doc/run/browser/performance/fast-load/cache/clientCache.html","title":"clientCache","keywords":"","body":"Cache 我们知道HTTP的缓存属于客户端缓存，后面会提到为什么属于客户端缓存。所以我们认为浏览器存在一个缓存数据库，用于储存一些不经常变化的静态文件（图片、css、js等）。我们将缓存分为强制缓存和协商缓存。下面我将分别详细的介绍这两种缓存的缓存规则。 缓存策略 强制缓存 当缓存数据库中已有所请求的数据时。客户端直接从缓存数据库中获取数据。当缓存数据库中没有所请求的数据时，客户端的才会从服务端获取数据。触发强制缓存后，Firefox浏览器表现为一个灰色的200状态码。chrome为200 (from disk cache)或是200 OK (from memory cache)，这里chrome会根据你的内存情况来选择存在内存还是硬盘 Expires Cache-Control max-age=[秒] 缓存的时长，也是响应的最大的Age值 no-store 不缓存请求或是响应的任何内容 no-cache 强制源服务器再次验证缓存是否可用 max-age=0和no-cache应该是从语气上不同。max-age=0是告诉客户端资源的缓存到期应该向服务器验证缓存的有效性。而no-cache则告诉客户端使用缓存前必须向服务器验证缓存的有效性。 private 客户端可以缓存 public 客户端和代理服务器都可以缓存 Cache-Control优先级大于Expires 协商缓存 又称对比缓存，客户端会先从缓存数据库中获取到一个缓存数据的标识，得到标识后请求服务端验证是否失效（新鲜），如果没有失效服务端会返回304，此时客户端直接从缓存中获取所请求的数据，如果标识失效，服务端会返回更新后的数据。 两类缓存机制可以同时存在，强制缓存的优先级高于协商缓存，当执行强制缓存时，如若缓存命中，则直接使用缓存数据库数据，不在进行缓存协商。 Last-Modified If-Moified-Since 在浏览器第一次请求某一个URL时，服务器端的返回状态码会是200，响应的实体内容是客户端请求的资源，同时有一个Last-Modified的属性标记此文件在服务器端最后被修改的时间。Last-Modified : Fri , 12 May 2006 18:53:33 GMT 当浏览器第二次请求这个URL的时候，根据HTTP协议规定，浏览器会把第一次Last-Modified的值存储在If-Modified-Since里面发送给服务端来验证资源有没有修改。If-Modified-Since : Fri , 12 May 2006 18:53:33 GMT 服务端通过If-Modified-Since字段来判断在这两次访问期间资源有没有被修改过，从而决定是否返回完整的资源。如果有修改正常返回资源，状态码200，如果没有修改只返回响应头，状态码304，告知浏览器资源的本地缓存还可用。 Last-Modified有几个缺点：没法准确的判断资源是否真的修改了，比如某个文件在1秒内频繁更改了多次，根据Last-Modified的时间(单位是秒)是判断不出来的，再比如，某个资源只是修改了，但实际内容并没有发生变化，Last-Modified也无法判断出来，因此在HTTP/1.1中还推出了ETag这个字段👇 Etag If-None-Match 在浏览器第一次请求某一个URL时，服务器可以通过某种自定的算法对资源生成一个唯一的标识(比如md5标识)， 并返给浏览器ETag: abc-123456 当浏览器第二次请求这个URL的时候，根据HTTP协议规定，浏览器回把第一次ETag的值存储在If-None-Match里面发送给服务端来验证资源有没有修改。If-None-Match: abc-123456 Get请求中，当且仅当服务器上没有任何资源的ETag属性值与这个首部中列出的相匹配的时候，服务器端会才返回所请求的资源，响应码为200。如果没有资源的ETag值相匹配，那么返回304状态码。 POST、PUT等请求改变文件的请求，如果没有资源的ETag值相匹配，那么返回412状态码。 当然和Last-Modified相比，ETag也有自己的缺点，比如由于需要对资源进行生成标识，性能方面就势必有所牺牲。 If-None-Match优先级大于Last-Modified启发式缓存 Age:23146 Cache-Control: public Date:Tue, 28 Nov 2017 12:26:41 GMT Last-Modified:Tue, 28 Nov 2017 05:14:02 GMT Vary:Accept-Encoding 如果浏览器用来确定缓存过期时间的字段一个都没有！那该怎么办？启发式缓存！ 根据响应头中2个时间字段 Date 和 Last-Modified 之间的时间差值，取其值的10%作为缓存时间周期。 用户行为 打开新窗口 如果指定cache-control的值为private、no-cache、must-revalidate,那么打开新窗口访问时都会重新访问服务器。而如果指定了max-age值,那么在此值内的时间里就不会重新访问服务器 在地址栏回车 如果值为private或must-revalidate,则只有第一次访问时会访问服务器,以后就不再访问。如果值为no-cache,那么每次都会访问。如果值为max-age,则在过期之前不会重复访问。 按后退按扭 如果值为private、must-revalidate、max-age,则不会重访问,而如果为no-cache,则每次都重复访问. 按刷新按扭 F5 无论为何值,都会重复访问.请求带上If-Modify-since，去服务器看看这个文件是否有过期了 按强制刷新按钮 CTRL/F5 浏览器删除缓存，当做首次进入重新请求(返回状态码200) 实践 最佳实践，就应该是尽可能命中强缓存，同时，能在更新版本的时候让客户端的缓存失效。 前端打包加hash webpack给我们提供了三种哈希值计算方式，分别是hash、chunkhash和contenthash hash 只要有一个文件变化，整个项目都hash都会变，显然不行 const path = require('path'); module.exports = { entry: { index: './src/index.js', main: './src/main.js' }, output: { path: path.resolve(__dirname, 'dist'), filename: '[name].[hash].js', } } chunkhash 同一模块中一个文件变化，整个模块hash变化。看起来还行，不过如果js和css是分开了的，只要其中一个变化，整个模块的js和css都会变 module.exports = { output: { path: path.resolve(__dirname, 'dist'), filename: '[name].[chunkhash].js', } } contenthash 只要文件内容不一样，文件产生的哈希值就不一样，显然这就是我们想要的 module.exports = { output: { path: path.resolve(__dirname, 'dist') filename: '[name].[contenthash].js', } }; Nginx 官方默认开启ETag，所以这里就不用做特别设置了 后端 强制缓存res.setHeader('Cache-Control', 'public, max-age=xxx'); 协商缓存res.setHeader('Cache-Control', 'public, max-age=0'); res.setHeader('Last-Modified', xxx); res.setHeader('ETag', xxx); 当然也有很多库,比如koa的koa-staticconst KoaStatic = require('koa-static'); app.use(KoaStatic('./',{ maxAge: 365 * 24 * 60 * 60 })); "},"doc/run/browser/performance/fast-load/cache/storage.html":{"url":"doc/run/browser/performance/fast-load/cache/storage.html","title":"storage","keywords":"","body":"storage "},"doc/run/browser/performance/fast-load/cache/offlineCache.html":{"url":"doc/run/browser/performance/fast-load/cache/offlineCache.html","title":"离线缓存","keywords":"","body":"离线缓存 "},"doc/run/browser/error-monitor/capture/capture.html":{"url":"doc/run/browser/error-monitor/capture/capture.html","title":"捕获异常","keywords":"","body":" 错误分类 js 错误 资源请求错误 接口报错 捕获方法分类 try-catch window.onerror=function(){...} window.addEventListener('error',function(){...}) window.addEventListener(\"unhandledrejection\", (e) => {...}); vue 项目 Vue.config.errorHandler = (error, vm, info) => {} react 项目 componentDidCatch(err,info){} try-catch js 报错机制，如果一个任务执行了一个错误的方法，后续程序执行停止了。但是另外一个任务并不会影响。 setTimeout(() => { console.log(\"start-1\"); console.log(a); console.log(\"end-1\"); }, 0); setTimeout(() => { console.log(\"start-2\"); console.log(\"end-2\"); }, 0); try catch 捕捉错误 setTimeout(() => { try { console.log(\"start-1\"); console.log(a); console.log(\"end-1\"); } catch (err) { console.log(\"catch\", err); } }, 0); setTimeout(() => { console.log(\"start-2\"); console.log(\"end-2\"); }, 0); 你可能想在底层 try-catch，但是 try-catch 在异步中会失效 try { setTimeout(() => { console.log(\"start-1\"); console.log(a); console.log(\"end-1\"); }, 0); setTimeout(() => { console.log(\"start-2\"); console.log(\"end-2\"); }, 0); } catch (err) { console.log(\"catch\", err); } window.onerror window.onerror 最大的好处就是可以同步任务还是异步任务都可捕获。 setTimeout(() => { console.log(\"start-1\"); console.log(a); console.log(\"end-1\"); }, 0); setTimeout(() => { console.log(\"start-2\"); console.log(\"end-2\"); }, 0); window.onerror = (...args) => { console.log(\"onerror\", args); return true; //如果不返回true,报错依然会上抛 }; 但是无法获取资源错误，比如 监听 error 事件 可以使用 addEventListener error 来捕获资源的错误 window.addEventListener( \"error\", (args) => { console.log(\"linstener err\", args); return true; }, { capture: true, //必须是捕获阶段，才可以捕获到资源错误 } ); window.onerror 和监听 error 事件，都捕获不到 promise，可以监听 unhandledrejection 来解决 监听 unhandledrejection 事件 window.addEventListener(\"unhandledrejection\", (e) => { console.log(\"unhandledrejection\", e.reason); throw e.reason; //这里可以抛出错误事件，之后交由window.onerror统一处理 }); new Promise((res, rej) => { error; }); //await也可以监听到 (async () => { await e; })(); 总结 异常类型 同步 异步 资源加载 promise try-catch 支持 onerror 支持 支持 监听 error 支持 支持 支持 监听 unhandledrejection 支持 终极方案 思路 针对 js 错误 使用onerror,因为 onerror 比监听 error 的信息更全 使用监听unhandledrejection 资源请求错误 使用监听error 接口报错 axios 中统一封装 框架错误 vue 项目 Vue.config.errorHandler = (error, vm, info) => {} react 项目 componentDidCatch(err,info){} 效果 实践 全局异常汇总 function reportError(type, err, ...other) { console.group(`捕获到错误：${err}`); console.log(`类型:${type}`); console.log(err); console.log(`其他：${other}`); console.groupEnd(); //这里可以做上传错误之类的... } js 错误 window.onerror = function (...args) { reportError(\"JsError\", args); }; 加载资源错误 window.addEventListener( \"error\", (event) => { // 过滤 js error const target = event.target || event.srcElement; const isElementTarget = target instanceof HTMLScriptElement || target instanceof HTMLLinkElement || target instanceof HTMLImageElement; if (!isElementTarget) { return false; } // 上报资源地址 const url = (target as HTMLScriptElement | HTMLImageElement).src || (target as HTMLLinkElement).href; reportError(\"ResourceLoadError\", url); }, true ); promise 类错误 window.addEventListener(\"unhandledrejection\", (e) => { throw e.reason; //抛出错误事件统一处理 }); vue 全局错误 Vue.config.errorHandler = (error, vm, info) => { reportError(info, error); }; axios 统一接口错误 ... .catch((error) => { reportError( \"NetworkError\", error, `${opt.method ? opt.method : \"get\"}===${opt.url}===${JSON.stringify( opt.data )}` ); } 使用 sentry 通过之前的错误收集，我们已经可以自己搭建一个异常监控平台了，当然你也可以选择其他成熟的监控平台，Sentry 就是这样一个平台。Sentry 是一个开源的实时错误追踪系统，可以帮助开发者实时监控并修复异常问题。提供了对多种主流语言和框架的支持，包括 React、Angular、Node、Django、RoR、PHP、Laravel、Android、.NET、JAVA 等。我们可以直接使用它家提供的在线服务，也可以本地自行搭建； 使用 Sentry "},"doc/run/browser/error-monitor/sentry/sentry.html":{"url":"doc/run/browser/error-monitor/sentry/sentry.html","title":"Sentry","keywords":"","body":" sentry Sentry 是一个开源的实时错误追踪系统，可以帮助开发者实时监控并修复异常问题。提供了对多种主流语言和框架的支持，包括 React、Angular、Node、Django、RoR、PHP、Laravel、Android、.NET、JAVA 等。我们可以直接使用它家提供的在线服务，也可以本地自行搭建； 使用在线服务 没什么好说的，官网直接用 私有化部署 拥有自己的异常监控平台，就很香 拉取镜像 docker pull redis docker pull postgres docker pull sentry 启动 redis 和 sentry docker run -d --name sentry-redis redis docker run -d --name sentry-postgres -e POSTGRES_PASSWORD=secret -e POSTGRES_USER=sentry postgres 获取密钥 docker run --rm sentry config generate-secret-key 这里会获得密钥，自己保存好，后面会用 启动服务 docker run -it --rm -e SENTRY_SECRET_KEY='你的密钥' --link sentry-postgres:postgres --link sentry-redis:redis sentry upgrade （这一步会提示使用邮箱和密码创建用户，之后可以进入my-sentry,使用sentry createuser再次建立） docker run -d -p 9000:9000 --name my-sentry -e SENTRY_SECRET_KEY='你的密钥' --link sentry-redis:redis --link sentry-postgres:postgres sentry docker run -d --name sentry-cron -e SENTRY_SECRET_KEY='你的密钥' --link sentry-postgres:postgres --link sentry-redis:redis sentry run cron docker run -d --name sentry-worker-1 -e SENTRY_SECRET_KEY='你的密钥' --link sentry-postgres:postgres --link sentry-redis:redis sentry run worker 查看容器 docker ps -a 查看容器，其中 my-sentry 是主程序 sentry-worker 是 sentry 的异步队列 sentry-corn 是 sentry 的定时任务 sentry-postgres 是数据库 sentry-redis 是缓存 配置邮箱 像测试邮件是使用 sentry 的主程序测试的，而平常收到的异常日志和邀请邮件是 sentry-worker 异步执行的，如果只改了主程序，那么就会出现测试邮件的时候正常，却收不到异常日志和邀请邮件的情况。 进入主容器 my-sentry cd /etc/sentry/ vim config.yml 如果没有安装 vim apt-get update apt-get install vim -y 配置 config.yml 邮箱设置 ############### # Mail Server # ############### # 修改这里，取消原本的注释 mail.backend: 'smtp' mail.host: 'smtp.qq.com' #邮箱对应的smtp域名 mail.port: 587 #邮箱对应端口 mail.username: 'xx@xx.com' #你的邮箱 mail.password: 'pwd' #你设置的密码，注意不是邮箱登录密码 mail.use-tls: true #是否使用tls连接 #The email address to send on behalf of mail.from: 'xx@xx.com' #发送者，填的和user一样就行 # If you'd like to configure email replies, enable this. exit 退出容器 docker restart xxxxx 重启容器 然后将 sentry-worker 容器也一样改掉就行。 项目使用 因为 onerror 信息比监听 error 更全，所以 sentry 是用的 onerror，和监听 unhandledrejection,这样我们只需要补全资源错误，vue/react项目错误,接口报错就可以了 整一个 Sentry 类出来，实现监听资源错误上报和暴露上报方法 // Report.ts import * as Sentry from \"@sentry/browser\"; import * as Integrations from \"@sentry/integrations\"; type Environment = \"production\" | \"development\"; interface ReportOptions { enabled?: boolean; dsn: string; release: string; environment: Environment; } class Report { public Vue: any; public options: ReportOptions; private static instance: Report; constructor(Vue: any, options: ReportOptions) { this.Vue = Vue; this.options = options; } public static getInstance(Vue: any, options: ReportOptions) { if (!this.instance) { this.instance = new Report(Vue, options); this.instance.init(); this.instance.loadListener(); } return this.instance; } // 初始化 public init() { Sentry.init({ enabled: this.options.enabled, dsn: this.options.dsn, integrations: [ new Integrations.Vue({ Vue: this.Vue, attachProps: true }), ], release: this.options.release, environment: this.options.environment, }); } // 主动上报 public log(info: any) { Sentry.withScope((scope) => { Object.keys(info).forEach((key) => { if (key !== \"error\") { scope.setExtra(key, info[key]); } }); Sentry.captureException(info.error || new Error(\"未知错误\")); }); } // 全局监控资源加载错误 public loadListener() { window.addEventListener( \"error\", (event) => { // 过滤 js error const target = event.target || event.srcElement; const isElementTarget = target instanceof HTMLScriptElement || target instanceof HTMLLinkElement || target instanceof HTMLImageElement; if (!isElementTarget) { return false; } // 上报资源地址 const url = (target as HTMLScriptElement | HTMLImageElement).src || (target as HTMLLinkElement).href; this.log({ error: new Error(`ResourceLoadError: ${url}`), type: \"resource load\", }); }, true ); } } export default Report; 添加 vue 全局错误上报 //main.ts //全局监控 const sentry = Report.getInstance(Vue, { enabled: process.env.NODE_ENV === \"production\", dsn: SENTRYDSN, release: version, environment: process.env.NODE_ENV, }); Vue.prototype.$sentry = sentry; Vue.config.errorHandler = (error, vm, info) => { console.log(\"errorHandler\", error, vm, info); vm.$sentry.log({ error, type: \"vue errorHandler\", vm, info, }); }; let VueApp = new Vue({ router, store, render: (h) => h(App), }).$mount(\"#app\"); export default VueApp; 添加 axios 接口错误上报 //fetch.ts import VueApp from \"@/main\"; axiosInstance.interceptors.response.use( (res) => { ... }, err => { VueApp.$sentry.log({ error: err, type: \"callNative\", config: err.config }); ... } ); "}}